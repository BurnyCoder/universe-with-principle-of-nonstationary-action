<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Least Action Particle Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-300 */
            overflow: hidden; /* Prevent scrollbars from canvas behavior */
        }
        #simulationCanvas {
            display: block;
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .controls {
            margin-top: 1.5rem; /* Tailwind mt-6 */
            display: flex;
            gap: 1rem; /* Tailwind space-x-4 */
        }
        .control-button {
            background-color: #4a5568; /* Tailwind gray-700 */
            color: #e2e8f0; /* Tailwind gray-300 */
            padding: 0.5rem 1rem; /* Tailwind px-4 py-2 */
            border: none;
            border-radius: 0.375rem; /* Tailwind rounded-md */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .control-button:hover {
            background-color: #718096; /* Tailwind gray-600 */
        }
        .info-text {
            margin-top: 1rem;
            font-size: 0.875rem; /* Tailwind text-sm */
            color: #a0aec0; /* Tailwind gray-500 */
            text-align: center;
        }
    </style>
</head>
<body>
    <h1 class="text-3xl font-bold mb-6 text-gray-100">2D Particle Simulation</h1>
    <p class="mb-4 text-gray-400 text-center max-w-xl">
        Particles move and bounce off walls. Their velocity is randomly perturbed at each step,
        meaning they don't follow paths of least action (e.g., straight lines in empty space).
    </p>
    <canvas id="simulationCanvas"></canvas>
    <div class="controls">
        <button id="resetButton" class="control-button">Reset Simulation</button>
        <button id="addParticleButton" class="control-button">Add Particle</button>
        <button id="removeParticleButton" class="control-button">Remove Particle</button>
    </div>
     <div class="info-text">
        Particle Count: <span id="particleCount">0</span>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const particleCountSpan = document.getElementById('particleCount');

        let particles = [];
        const numInitialParticles = 20;
        const particleRadius = 5;
        const perturbationStrength = 0.2; // How much to randomly change velocity

        // Function to generate a random color
        function getRandomColor() {
            const r = Math.floor(Math.random() * 200) + 55; // Avoid very dark colors
            const g = Math.floor(Math.random() * 200) + 55;
            const b = Math.floor(Math.random() * 200) + 55;
            return `rgb(${r},${g},${b})`;
        }

        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = particleRadius;
                this.color = color || getRandomColor();
            }

            // Draw the particle
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            // Update particle position and apply "non-least action" perturbation
            update() {
                // Standard motion
                this.x += this.vx;
                this.y += this.vy;

                // "Non-least action" perturbation:
                // Add a small random change to velocity. This "force" is not derived
                // from a potential field, so the particle won't follow a path of least action.
                this.vx += (Math.random() - 0.5) * perturbationStrength;
                this.vy += (Math.random() - 0.5) * perturbationStrength;

                // Optional: Max speed to prevent them from becoming too fast
                const maxSpeed = 3;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // Boundary checks (bounce off walls)
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.vx *= -1;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); // Clamp position
                }
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.vy *= -1;
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); // Clamp position
                }
            }
        }

        // Initialize particles
        function initParticles() {
            particles = [];
            for (let i = 0; i < numInitialParticles; i++) {
                addOneParticle();
            }
            updateParticleCountDisplay();
        }

        function addOneParticle() {
            const x = Math.random() * (canvas.width - 2 * particleRadius) + particleRadius;
            const y = Math.random() * (canvas.height - 2 * particleRadius) + particleRadius;
            const vx = (Math.random() - 0.5) * 4; // Random initial velocity x
            const vy = (Math.random() - 0.5) * 4; // Random initial velocity y
            particles.push(new Particle(x, y, vx, vy));
            updateParticleCountDisplay();
        }

        function removeOneParticle() {
            if (particles.length > 0) {
                particles.pop();
            }
            updateParticleCountDisplay();
        }
        
        function updateParticleCountDisplay() {
            particleCountSpan.textContent = particles.length;
        }


        // Animation loop
        function animate() {
            // Clear the canvas with a slight fade effect for trails (optional)
            // ctx.fillStyle = 'rgba(45, 55, 72, 0.3)'; // Tailwind gray-800 with alpha
            // ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Or a solid clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);


            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            requestAnimationFrame(animate);
        }

        // Resize canvas function
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            // Set a max width and height for the canvas, e.g., 800x600
            // Or make it a percentage of the window size
            const maxWidth = 800;
            const maxHeight = 600;
            
            const newWidth = Math.min(window.innerWidth * 0.9, maxWidth);
            const newHeight = Math.min(window.innerHeight * 0.7, maxHeight);

            canvas.width = newWidth * dpr;
            canvas.height = newHeight * dpr;
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            
            ctx.scale(dpr, dpr);


            // Re-initialize particles if canvas size changes significantly to prevent clumping
            // or if they are outside new bounds. For simplicity, we'll just let them adjust.
            // If particles array exists, ensure they are within new bounds
            if (particles.length > 0) {
                 particles.forEach(p => {
                    p.x = Math.max(p.radius, Math.min(canvas.width / dpr - p.radius, p.x));
                    p.y = Math.max(p.radius, Math.min(canvas.height / dpr - p.radius, p.y));
                 });
            }
        }

        // Event Listeners
        document.getElementById('resetButton').addEventListener('click', () => {
            // Re-initialize particles on reset
             const currentParticleCount = particles.length > 0 ? particles.length : numInitialParticles;
             particles = []; // Clear existing
             for (let i = 0; i < currentParticleCount; i++) {
                addOneParticle();
             }
        });
        
        document.getElementById('addParticleButton').addEventListener('click', addOneParticle);
        document.getElementById('removeParticleButton').addEventListener('click', removeOneParticle);

        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        resizeCanvas(); // Set initial canvas size
        initParticles(); // Create particles
        animate(); // Start animation
    </script>
</body>
</html>
